1、generator的基本概念
  一是，function关键字与函数名之间有一个星号;
  二是，函数体内部使用yield表达式，定义不同的内部状态

  调用generator函数后，该函数并不执行，返回的是一个指向内部状态的指针对象（遍历器对象），然后，再调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，知道遇到下一个yield表达式（或return语句）为止。

  function* helloWorldGenerator() {
    yield 'hello';
    yield 'world';
    return 'ending';
  }

  var hw = helloWorldGenerator();
  hw.next() // { value: 'hello', done: false }
  hw.next() // { value: 'world', done: false }
  hw.next() // { value: 'ending', done: true }
  hw.next() // { value: undefined, done: true }

2、yield表达式
  用于暂停执行generator函数的next（）遍历，并将紧跟着yield后面的表达式作为返回对象的value属性值
  注意
    1）只能用在generator函数里面，其他地方都会报错
    2）generator函数只有遇到next（）方法才能执行
    3）yield表达式用在其他表达式中，必须放在圆括号里面
      function* demo() {
        console.log('Hello' + yield 123); // SyntaxError
        console.log('Hello' + (yield 123)); // OK
      }
    4）如果用作函数参数或放在赋值表达式的右边，可以不加括号
      function* demo() {
        foo(yield 'a', yield 'b'); // OK
        let input = yield; // OK
      }

3、与iterator接口的关系
  有与generator函数就是遍历器生成函数，因此可以吧generator复制给对象的Symbol.iterator属性，从而使得该对象具有iterator接口
  var myIterable = {};
  myIterable[Symbol.iterator] = function* () {
    yield 1;
    yield 2;
    yield 3;
  };

  [...myIterable] // [1, 2, 3]