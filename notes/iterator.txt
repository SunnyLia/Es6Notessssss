iterator( 遍历器)
1、作用
  1）为各种数据结构，提供一个统一的、简便的访问接口
  2）能够使数据结构的成员按某种次序排列
  3）供for...of搭配使用
2、遍历过程
  每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束

3、默认iterator接口
  Array
  Map
  Set
  String
  TypedArray
  函数的 arguments 对象
  NodeList 对象

4、调用iterator接口的场合
  1）解构赋值
    对数组和set结构进行解构赋值
      let set = new Set().add('a').add('b').add('c');
      let [x,y] = set;
      // x='a'; y='b'
      let [first, ...rest] = set;
      // first='a'; rest=['b','c'];
  2）扩展运算符（...）
    // 例一
    var str = 'hello';
    [...str] //  ['h','e','l','l','o']
    // 例二
    let arr = ['b', 'c'];
    ['a', ...arr, 'd']
    // ['a', 'b', 'c', 'd']
  3) yield*
    let generator = function* () {
      yield 1;
      yield* [2,3,4];
      yield 5;
    };

    var iterator = generator();
    iterator.next() // { value: 1, done: false }
    iterator.next() // { value: 2, done: false }
    iterator.next() // { value: 3, done: false }
    iterator.next() // { value: 4, done: false }
    iterator.next() // { value: 5, done: false }
    iterator.next() // { value: undefined, done: true }
  4) 其他场合
    for...of
    Array.from()
    Map(), Set(), WeakMap(), WeakSet()（比如new Map([['a',1],['b',2]])）
    Promise.all()
    Promise.race()

5、for...of循环
  一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用for...of循环遍历它的成员(键值)
  1）数组
    const arr = ['red', 'green', 'blue'];
    for(let v of arr) {
      console.log(v); // red green blue
    }
    const obj = {};
    obj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);
    for(let v of obj) {
      console.log(v); // red green blue
    }

  2）Set和Map结构
    var engines = new Set(["Gecko", "Trident", "Webkit", "Webkit"]);
    for (var e of engines) {
      console.log(e);
    }
    // Gecko
    // Trident
    // Webkit

    var es6 = new Map();
    es6.set("edition", 6);
    es6.set("committee", "TC39");
    es6.set("standard", "ECMA-262");
    for (var [name, value] of es6) {
      console.log(name + ": " + value);
    }
    // edition: 6
    // committee: TC39
    // standard: ECMA-262

  3）