const asyncReadFile = async function () {
  const f1 = await readFile('/etc/fstab');
  const f2 = await readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
};
1、特点
  1）内置执行器
    generator函数的执行必须靠执行器或next方法，而async函数自带执行器，可以与普通函数一样执行
    asyncReadFile();
  2）更好的语义
    async函数就是将generator函数的星号（*）替换成async,将yield替换成await
  3）更广的适用性
    await命令后面，可以是promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）
  4）返回值是promise
    async函数的返回值是promise对象，这比generator函数的返回值是iterator对象方便多了，可以用then方法指定下一步的操作

2、基本用法
  async函数返回一个promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句
    async function timeout(ms) {
      await new Promise((resolve) => {
        setTimeout(resolve, ms);
      });
    }
    async function asyncPrint(value, ms) {
      await timeout(ms);
      console.log(value);
    }
    asyncPrint('hello world', 50);

3、语法
  1）返回promise对象
    async函数内部return语句返回的值，会成为then方法回调函数的参数
      async function f(){
        return 'hello world';
      }
      f().then(v => console.log(v)); //hello world
  2）async函数内部抛出的错误，会被catch方法接收到
    async function f(){
      throw new Error('出错了');
    };
    f().then(v => console.log(v))
    .catch(e => console.log(e))

4、await命令
  只要await语句后面的promise变为reject，那么整个async函数都会中断执行
  所以，即使前一个异步操作失败，也不要中断后面的异步函数，
  1）用try...catch
    async function f() {
      try {
        await Promise.reject('出错了');
      } catch(e) {
      }
      return await Promise.resolve('hello world');
    }

    f()
    .then(v => console.log(v))
    // hello world

  2）await后面的promise对象后再跟一个catch方法
    async function f() {
      await Promise.reject('出错了')
        .catch(e => console.log(e));
      return await Promise.resolve('hello world');
    }

    f()
    .then(v => console.log(v))
    // 出错了
    // hello world

  3）如果希望多个请求并发执行，可以使用promise.all方法
    async function dbFuc(db) {
      let docs = [{}, {}, {}];
      let promises = docs.map((doc) => db.post(doc));

      let results = await Promise.all(promises);
      console.log(results);
    }

5、for await...of
  用于遍历异步的iterator接口
  async function f() {
    for await (const x of createAsyncIterable(['a', 'b'])) {
      console.log(x);
    }
  }
  // a
  // b